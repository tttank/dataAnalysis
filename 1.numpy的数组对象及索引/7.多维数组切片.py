import numpy as np

# 多维数组切片
a = np.array([[0, 1, 2, 3, 4, 5], [10, 11, 12, 13, 14, 15],
              [20, 21, 22, 23, 24, 25], [30, 31, 32, 33, 34, 35],
              [40, 41, 42, 43, 44, 45], [50, 51, 52, 53, 54, 55]])
print(a)
# [[ 0  1  2  3  4  5]
#  [10 11 12 13 14 15]
#  [20 21 22 23 24 25]
#  [30 31 32 33 34 35]
#  [40 41 42 43 44 45]
#  [50 51 52 53 54 55]]

# 想得到第一行的第四和第五两个元素
print(a[0, 3:5])

# 得到最后两行的最后两列
print(a[-2:, -2:])

# 得到第三列
print(a[:, 2])
# 第三行
print(a[2])

# 每一维都支持切片的规则，包括负索引，省略: [lower:upper:step]

# 取出3， 5行的奇数列
print(a[2::2, ::2])

"""
（1）切片在内存中使用的是引用机制。
引用机制意味着，Python并没有为b分配薪的空间来存储它的值，而是让b指向了a所分配的内存空间，因此改变b会改变a的值
（2）而这种现象在列表中并不会出现
引用机制这样做的好处在于，对于很大的数组，不用大量渎职多余的值，节约了空间
缺点在于，可能出现改变一个值导致另一个值的改变
（3）一个解决方式是使用copy() 方法产生一个复制，这个复制会申请薪的内存
"""
# （1）数组中切片是引用
a = np.array([1, 2, 3, 4, 5])
b = a[2:4]  # 将a的切片赋值给b
print(b)  # [3 4]
b[0] = 10  # 将b中索引为0的值赋值为10
print(a)  # [ 1  2 10  4  5]
# 由此可看出 数组b中值的改变导致a值的改变

print('~' * 50)  # 分割线

# (2) 列表中
a = [1, 2, 3, 4, 5]
b = a[2:4]
print(b)  # [3, 4]
b[0] = 10
print(a)  # [1, 2, 3, 4, 5]

print('~'*50)

# （3） 使用copy() 产生新内存，使其互不干扰
a = np.array([1, 2, 3, 4, 5])
b = a[2:4].copy()
b[0] = 10
print(a)  # [1 2 3 4 5]

